The RasterGraph class contains a data structure designed for easy and computationally efficient distance and cost calculations on geographic images, e.g. satellite data, and several methods with which to generate said cost calculations. \
To initialize a rasterGraph object, a geotransform and a 2D array of values are required. Images should be in WGS84/EPSG:4326 format. Images must be aligned north-south so that every pixel in the same row in the array also has the same latitude.

Once initialized, a RasterGraph object contains the following attributes:\
A 2D array of values representing a friction surface\
A geotransform\
A longitudinal pixel y scale, extracted from the geotransform\
A longitudinal pixel x scale, extracted from the geotransform\
A pixel y scale in meters, computed from the longitudinal pixel y scale\
A dictionary of pixel x scales in meters for each row in the array\
A dictionary of nodes, comprising the friction array in graph form. Each node is indexed by its [y, x] coordinates in the array. The nodes value is a tuple, containing the coordinates of the <= 8 connected nodes, and the weight stored in the current node’s position in the array. As this graph is node-weighted, the weight of each node will determine the cost of traversing any edges from the current node to any connected node.

NB: array coordinates are stored as [y, x] as opposed to [x, y]:\
Each point in the rasterGraph represents a physical point in space on the surface of the earth. In designing this object class, I wanted to associate x with the east-west axis and y with the north-south axis, thus requiring the indexing convention [y, x] for the row-major numpy array encoding the input raster.

Initialization contains several steps that I feel are useful to explain in detail.\
Precomputing longitudinal widths at each latitude:\
It is intended that the friction surface passed in to the RasterGraph initialization comes from a raster in the EPSG:4326 projection, so that pixel width and length are fractions of a degree of longitude and latitude. One degree of latitude is invariably 111km in length, but the length of one degree of longitude can vary with the latitude at which the measurement is taken. To ensure that all distances are correctly computed in the implementation of Dijkstra’s algorithm, pixel horizontal length in meters is precomputed and stored in a dictionary keyed by the row number for all rows in the image. Significant time and space is saved by precomputing one value per row as opposed to computing this value for each pixel. This is why I have implemented the requirement that all input images be north-south oriented.

The relevant functions are getPixelXScale (for a single node) and getPixelXScales (applies the previous function to each node)

Building the node graph:\
The graph upon which our search algorithm is run is encoded as a dictionary with coordinate keys and (neighbors, weight) nodes. For each key, getting the weight portion of the value requires looking up the value stored in the input friction surface array at the given coordinates. The neighbors portion of the value is generated by appending all coordinates within a 3x3 window about the current coordinate, save for the current coordinate itself.

The relevant functions are getNeighbors and getAllNodes

In addition to the methods involved in initializing a RasterGraph object, the class contains several methods implementing algorithms to compute cumulative traversal costs and least cost paths on the surface passed into the object during initialization. These are:\
buildCumulativeCost(self, startNodes, endNode=None)\
the first part of Dijkstra's algorithm. Takes a list of start nodes and
    returns a coordinate-indexed dictionary of cumulative costs and a
    coordinate indexed ditionary ofthe previous coordinate traversed for each
    coordinate. NB that this function does not return a numpy array of
    cumulative costs; call cumulativeCostToArray() method if array format is
    desired.\
tracebackPath(self, shortestPathTree, endNode=None)\
The second half of dijkstra's algorithm. Takes a shortestPathTree
   (a dictionary containing node coordinate keys with parent node as value),
   and end node from which to start backward tracing. Returns a tuple containing:
   (the shortest path from the end node to the starting region, the length of
   the path in miles, the shortestPathTree).\
dijkstrasAlgorithm(self, startNodes, endNode=None)\
Implementation of Dijkstra's algorithm. Takes start nodes as a tuple, and
   an end node. Returns an array of cumulative costs, and a pathInfo tuple
   generated by tracebackPath. If endNode is None, the CC map will be
   generated but pathInfo will contain ([], 0, {}).

These methods are supported by the following helper functions:\
getPathLength(self, path)\
computes the length of a path in miles. Takes a path, as a traceback
   dictionary, and returns the length of the path in miles as a double.
cumulativeCostToArray(self, cumulativeCost)\
helper function to convert cumulative cost from dictionary to array.
   Takes a cumulative cost dictionary and returns it as an array.
pathToArray(self, path, width=1)\
helper function to convert path list to array. takes a path list and a
   desired path width (for display purposes) and returns a binary array where
   1s represent coordinates through which the path passes

DijkstraUtils.ipynb also contains two functions external to the RasterGraph class that handle data I/O. These are:\
readFrictionTiff(path)\
saveRasterAsGTiff(raster, filename, geotransform)
